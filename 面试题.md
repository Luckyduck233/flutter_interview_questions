# 面试题

# Flutter-知识型

## Widget概念

Flutter中几乎所有的对象都是一个 `Widget`，与原生开发中的`控件`不同的是，Flutter中的widget的概念更加广泛，不仅可以表示UI元素，还可以表示一些功能性的组件如：手势类GestureDetector和InkWell、用于App主题数据传递的 `Theme`等，而原生开发中的控件通常只是指UI元素，



Flutter中是通过Widget嵌套Widget的方式来构建UI和实现事件处理的



Widget的功能是 `描述一个UI元素的配置信息`



当我们在Flutter中创建和调用Widget时，实际上是在构建一个描述用户界面的树状结构。

这个树状结构由三部分组成：`Widget`、`Element`和`RenderObject`

1. Widget

   `Widget`是Flutter中构建用户界面的基本单元。它们描述了界面的外观和行为，可以是无状态的或者有状态的。`Widget`本身是不可改变的，即一旦创建，就不能更改。

2. Element

   `Element`负责将Widget转化为实际的渲染对象并管理其生命周期。每个`Widget`都会有对应的`Element`，`Element`是可变的，并且负责于底层渲染引擎进行交互。当`Widget`需要更新时，`Element`会负责更新对应的`RenderObject`

3. RenderObject-渲染树

   `RenderObject`是Flutter中的渲染对象，它负责将界面渲染到屏幕上。每个`Element`都对应一个`RenderObject`，`RenderObject`是真正与底层渲染引擎交互的对象，它将`Widget`的描述转化为可视的界面，最后根据 `RenderObject树`生成 `Layer树`，然后上屏显示，Layer树中的节点都继承自 `Layer类`



真正的布局和渲染逻辑在 `Render`树中，Element是Widget和RenderObject的粘合剂，可以理解为一个中间代理



在Flutter的渲染过程中，`Widget`通过`Element`进行管理和更新，`Element`负责创建和管理对应的`RenderObject`，最终将界面渲染到屏幕上。整个过程是一个从上到下的过程，从根节点开始递归构建和渲染整个`Widget`树

因此我们可以知道，Widget并不是真正的渲染对象，Flutter中渲染经历了从`Widget`-`Element`-`RenderObject`的过程



## 线程

### 四大线程

1. 原生线程
2. UI线程
3. GPU线程
4. IO线程









## 异步

### Future

##### 内置方法

- then()

  then()方法注册了一个回调函数，当Future完成时，回调函数将会被调用，并接收异步操作的结果

- catchError()

  如果异步操作发生错误，可以使用catchError()方法注册一个错误处理的回调函数

- whenComplete()

  whenComplete()方法用于注册一个回调函数，它不接收或传递任何参数，它的作用只是当Future完成后执行且无论Future成功或者失败都会被执行





## 布局

Layout布局过程主要是确定每一个组件的布局信息(大小和位置)，Flutter的布局过程如下

1. 父节点向子节点传递约束，限制子节点的最大和最小宽高
2. 子节点根据约束确定自己的大小
3. 父节点根据特定的布局规则(不同的布局组件会有不同的布局算法)确定每一个子节点在父节点布局空间中的位置，用偏移量offset表示
4. 递归整个过程，确定出每一个节点的大小和位置

可以得出结论，组件大小是由自身决定的，而组件的位置是由父组件决定的







## Key

### 什么是Key

在Flutter中，key作用是做组件的唯一标识，当Flutter框架需要更新组件时，它会通过比较组件的类型和组件key值来判断组件是否需要更新











### 在Widget中的作用

组件的key属性主要作用是决定在下一次 `build `时是复用旧widget还是构建一个新widget













































## State

### 生命周期

- initState

  当Widget第一次被插入到widget树时会被调用，对于每一个State对象，Flutter框架只会调用一次该回调，所以在该回调中做一些一次性的操作，如状态初始化、订阅事件等。

  不能在该回调中调用 `BuildContext.dependOnInheritedWidgetOfExactType（该方法用于在Widget树上获取距离当前widget最近的一个父级InheritedWidget）`，原因是在初始化完成后（initState方法执行后），widget树中的 `InheritFromWidget`也可能会发生变化，所以正确的做法应该在 `build`或者 `didChangeDependencies`中调用它

- didChangeDependencies

  当State对象的依赖发生变化时会被调用，例如在之前 `build`中包含了一个 `InheritedWidget`，然后在之后的 `build`中 `InheritedWidget`发生了变化，那么此时 `InheritedWidget`的子widget的 `didChangeDependencies`回调都会被调用。

  典型的场景是当系统语言Locale或应用主题改变时，Flutter框架会通知widget调用此回调。

  需要注意，组件第一次被创建后挂载的时候（包括重创建）对应的 `didChangeDependencies`也会被调用
  
- build

  主要是用于构建widget子树的，会在以下场景被调用

  - initState之后
  - didChangeDependencies之后
  - setState之后
  - didUpdateWidget之后
  - 在State对象从树中一个位置移除后（deactivate）又重新插入到树的其它位置之后

- didUpdateWidget

  在widget重新构建时，Flutter框架会调用 `widget.canUpdate`来检测widget树中同一位置的新旧节点，然后再决定是否需要重新构建当前widget，如果 `widget.canUpdate`返回true则调用此回调

  ```dart
  static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        && oldWidget.key == newWidget.key;
  }
  ```

- deactivate

  当State对象从树中被移除时，会调用此回调

  在一些场景下，Flutter框架会将State对象重新插入树中，例如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现），如果移除后没有重新插入到树中则紧接着会调用 `dispose`方法

- dispose

  当State对象从树中被永久移除时调用，通常在此回调中释放资源

<img src="C:\Users\27822\AppData\Roaming\Typora\typora-user-images\image-20230728180108941.png" alt="image-20230728180108941" style="zoom:80%;" />





### 在widget树中获取State对象

由于 `StatefulWidget`的具体逻辑方法都在其 `State`中，所以很多时候是需要获取 `StatefulWidget`对应的 `State`对象来调用一些方法，比如 `Scaffold`组件对应的状态类 `ScaffoldState` 就定义了打开 `SnackBar`的方法和打开 `Drawer`的方法

我们有两种方法在子树中获取父级State对象

#### 通过Context获取

`context`有一个 `findAncestorStateOfType`方法，该方法可以从当前节点沿着widget树向上查找指定类型的 `StatefulWidget`对应的 `State`对象

```dart
//查找父级最近的Scaffold对应的ScaffoldState对象
ScaffoldState _state = context.findAncestorStateOfType<ScaffoldState>()!;
//打开drawer
_state.openDrawer();
```



#### 通过GlobalKey

1. 给目标 `StatefulWidget`添加 `GlobalKey`

2. 通过 `GlobalKey` 来获取 `State` 对象

   ```dart
   globalKey.currentState.OpenDrawer();
   ```

GlobalKey是Flutter提供的一种在整个App中引用element的机制，如果一个Widget设置了Globalkey，那么我们便可以通过 `globalKey.currentWidget`来获取该widget对象、 `globalKey.currentElement`来获取widget对应的element对象、如果当前的widget是 `StatefulWidget`，则可以通过 `globalKey.currentState`来获取该widget对应的state对象





## 状态管理

### 简介

StatefulWidget的状态应该被谁管理？Widget本身？父Widget？都可以？还是另一个对象？答案取决于实际情况，以下是管理状态的最常见的方法

- Widget管理自己的状态
- Widget管理子Widget的状态
- 混合管理（父Widget和子Widget都管理状态）

如何决定使用哪种管理方法？下面是flutter官方给出的一些原则

- 如果状态是用户数据，如复选框的选中状态、滑块的位置，则该状态最好由父Widget管理
- 如果状态是有关界面外观效果的，如颜色、动画，那么状态最好由Widget本身来管理
- 如果某一个状态是不同Widget共享则由它们共同的父Widget管理  

在Widget内部管理状态它的封装性会好一些，而在父Widget中管理会比较灵活（灵活会显得更重要一些）



### Widget管理自身状态

我们实现一个TapboxA，在它对应的_TapboxAState 类:

- 管理TapboxA的状态。
- 定义`_active`：确定盒子的当前颜色的布尔值。
- 定义`_handleTap()`函数，该函数在点击该盒子时更新`_active`，并调用`setState()`更新UI。
- 实现widget的所有交互式行为。

```dart
// TapboxA 管理自身状态.

//------------------------- TapboxA ----------------------------------

class TapboxA extends StatefulWidget {
  TapboxA({Key? key}) : super(key: key);

  @override
  _TapboxAState createState() => _TapboxAState();
}

class _TapboxAState extends State<TapboxA> {
  bool _active = false;

  void _handleTap() {
    setState(() {
      _active = !_active;
    });
  }

  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _handleTap,
      child: Container(
        child: Center(
          child: Text(
            _active ? 'Active' : 'Inactive',
            style: TextStyle(fontSize: 32.0, color: Colors.white),
          ),
        ),
        width: 200.0,
        height: 200.0,
        decoration: BoxDecoration(
          color: _active ? Colors.lightGreen[700] : Colors.grey[600],
        ),
      ),
    );
  }
}
```





### 父Widget管理子Widget的状态

 `ParentWidgetState`类

- 为TapboxB管理 `_active`状态
- 实现 `_handleTapboxChanged()`，当盒子被点击时调用的方法
- 当状态改变时，调用 `setState`更新UI



`TabboxB`类

- 继承 `StatelessWidget`类，因为所有的状态都由其父组件处理
- 当检测到点击时，它会通知父组件



```dart
// ParentWidget 为 TapboxB 管理状态.

//------------------------ ParentWidget --------------------------------

class ParentWidget extends StatefulWidget {
  @override
  _ParentWidgetState createState() => _ParentWidgetState();
}

class _ParentWidgetState extends State<ParentWidget> {
  bool _active = false;

  void _handleTapboxChanged(bool newValue) {
    setState(() {
      _active = newValue;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      child: TapboxB(
        active: _active,
        onChanged: _handleTapboxChanged,
      ),
    );
  }
}

//------------------------- TapboxB ----------------------------------

class TapboxB extends StatelessWidget {
  TapboxB({Key? key, this.active: false, required this.onChanged})
      : super(key: key);

  final bool active;
  final ValueChanged<bool> onChanged;

  void _handleTap() {
    onChanged(!active);
  }

  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _handleTap,
      child: Container(
        child: Center(
          child: Text(
            active ? 'Active' : 'Inactive',
            style: TextStyle(fontSize: 32.0, color: Colors.white),
          ),
        ),
        width: 200.0,
        height: 200.0,
        decoration: BoxDecoration(
          color: active ? Colors.lightGreen[700] : Colors.grey[600],
        ),
      ),
    );
  }
}
```



### 混合状态管理

组件管理自身的一些内部状态，而父组件管理一些其它外部状态



在下面 TapboxC 示例中，手指按下时，盒子的周围会出现一个深绿色的边框，抬起时，边框消失。点击完成后，盒子的颜色改变。 TapboxC 将其`_active`状态导出到其父组件中，但在内部管理其`_highlight`状态。这个例子有两个状态对象`_ParentWidgetState`和`_TapboxCState`。



`_ParentWidgetStateC`类:

- 管理`_active` 状态。
- 实现 `_handleTapboxChanged()` ，当盒子被点击时调用。
- 当点击盒子并且`_active`状态改变时调用`setState()`更新UI。



`_TapboxCState` 对象:

- 管理`_highlight` 状态。
- `GestureDetector`监听所有tap事件。当用户点下时，它添加高亮（深绿色边框）；当用户释放时，会移除高亮。
- 当按下、抬起、或者取消点击时更新`_highlight`状态，调用`setState()`更新UI。
- 当点击时，将状态的改变传递给父组件。



```dart
//---------------------------- ParentWidget ----------------------------

class ParentWidgetC extends StatefulWidget {
  @override
  _ParentWidgetCState createState() => _ParentWidgetCState();
}

class _ParentWidgetCState extends State<ParentWidgetC> {
  bool _active = false;

  void _handleTapboxChanged(bool newValue) {
    setState(() {
      _active = newValue;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      child: TapboxC(
        active: _active,
        onChanged: _handleTapboxChanged,
      ),
    );
  }
}

//----------------------------- TapboxC ------------------------------

class TapboxC extends StatefulWidget {
  TapboxC({Key? key, this.active: false, required this.onChanged})
      : super(key: key);

  final bool active;
  final ValueChanged<bool> onChanged;
  
  @override
  _TapboxCState createState() => _TapboxCState();
}

class _TapboxCState extends State<TapboxC> {
  bool _highlight = false;

  void _handleTapDown(TapDownDetails details) {
    setState(() {
      _highlight = true;
    });
  }

  void _handleTapUp(TapUpDetails details) {
    setState(() {
      _highlight = false;
    });
  }

  void _handleTapCancel() {
    setState(() {
      _highlight = false;
    });
  }

  void _handleTap() {
    widget.onChanged(!widget.active);
  }

  @override
  Widget build(BuildContext context) {
    // 在按下时添加绿色边框，当抬起时，取消高亮  
    return GestureDetector(
      onTapDown: _handleTapDown, // 处理按下事件
      onTapUp: _handleTapUp, // 处理抬起事件
      onTap: _handleTap,
      onTapCancel: _handleTapCancel,
      child: Container(
        child: Center(
          child: Text(
            widget.active ? 'Active' : 'Inactive',
            style: TextStyle(fontSize: 32.0, color: Colors.white),
          ),
        ),
        width: 200.0,
        height: 200.0,
        decoration: BoxDecoration(
          color: widget.active ? Colors.lightGreen[700] : Colors.grey[600],
          border: _highlight
              ? Border.all(
                  color: Colors.teal[700],
                  width: 10.0,
                )
              : null,
        ),
      ),
    );
  }
}
```



开发人员只需要关心该状态框是否处于active状态，而不在乎高亮显示是如何管理的，所以让TapBox内部处理这些细节





### 全局状态管理

当应用中需要一些跨组件（跨路由）的状态需要同步时，上面介绍的方法便很难胜任了。比如我们有一个设置App主题的页面，为了让设置主题实时生效，我们希望在主题状态发生改变时，App中的主题组件能够重新build，但实现主题组件的页面和设置主题的页面并不在一起，所以以上三种实现状态管理的方法就很难实现需求了。这是需要一个全局状态管理器来处理这种组件之间的通信，目前有两种办法实现：

1. 实现一个全局的事件总线，将主题状态改变对应为一个事件，然后在App中依赖主题的组件的 `initState`方法中订阅设置主题页面里主题改变的事件。当用于在主题设置页切换主题状态后，我们发布 `主题切换事件`，而订阅了此事件的组件就会收到通知，收到后调用 `setState`方法重新build即可
2. 使用专门用于状态管理的包，如Provider、Bloc、Redux、GetX等













# Flutter-技术型

## 布局是如何实现的？有哪些常用的布局类？

在Flutter中，布局是通过一种树状结构的组件树来实现的。每个`Widget`都负责定义一部分或整个用户界面的外观和行为。`Widget`可以包含或嵌套其它`Widget`，从而实现复杂的布局。



### 常用的布局类有以下

1. Container-容器

   `Container`是一个多功能的布局类，用于包装其它`Widget`，并定义它们的尺寸、样式及约束

2. Row-Column-水平/垂直布局

   `Row`和`Column`分别是水平布局和垂直布局，它们都是用于将`子Widget`水平或垂直排列

3. Stack-层叠布局

   `Stack`是层叠布局，它是一个可以将`子Widget`按照堆叠顺序叠加在一起的布局类

4. ListView-列表布局

   `ListView`是一个可滚动的线性布局类，用于展示一个可滚动的列表。可以使用`ListView`显示大量的数据，例如聊天记录，商品列表等

5. GridView-网格布局

   `GridView`是一个二维的布局类，用于展示具有行和列的网格布局，可以使用`GridView`展示图库、瀑布流布局等





## 事件处理是如何实现的？有哪些常用的事件类？

Flutter事件处理流程主要分为两步

1. 命中测试

   当手指按下后，触发`PointerDownEvent`事件，按照深度优先遍历当前渲染`RenderObject`树，对每一个渲染对象进行`命中测试(hitTest)`，如果命中测试通过，则该渲染对象会被添加到一个`HitTestResult`列表当中

2. 事件分发

   命中测试完毕后，会遍历`HitTestResult`列表，调用每一个渲染对象的事件处理方法(handleEvent)来处理`PointerDownEvent`事件，该过程称为`事件分发(event dispatch)`。随后当手指移动时，便会分发`PointerMoveEvent`事件

3. 事件清理

   当手指抬起`PointerUpEvent`或者事件取消时`PointerCancelEvent`，会对相应事件进行分发，分发完毕后会清空`HitTestResult`列表

需要注意！！！

- 命中测试是在`PointerDownEvent`事件触发时进行的，一个完成的事件流是`down > move > up > cancle`
- 如果父子组件都监听了同一事件，则子组件会比父组件先响应事件。这是因为命中测试过程是按照深度优先规则遍历的，所以子渲染对象会比父渲染对象先加入`HitTestResult`列表，又因为在事件分发时是从前往后遍历`HitTestResult`列表的，所以子组件比父组件会更先被调用`handleEvent`

从代码层面看一些整个事件处理流程

```dart
// 触发新事件时，flutter 会调用此方法
void _handlePointerEventImmediately(PointerEvent event) {
  HitTestResult? hitTestResult;
  if (event is PointerDownEvent ) {
    hitTestResult = HitTestResult();
    // 发起命中测试
    hitTest(hitTestResult, event.position);
    if (event is PointerDownEvent) {
      _hitTests[event.pointer] = hitTestResult;
    }
  } else if (event is PointerUpEvent || event is PointerCancelEvent) {
    //获取命中测试的结果，然后移除它
    hitTestResult = _hitTests.remove(event.pointer);
  } else if (event.down) { // PointerMoveEvent
    //直接获取命中测试的结果
    hitTestResult = _hitTests[event.pointer];
  }
  // 事件分发
  if (hitTestResult != null) {
    dispatchEvent(event, hitTestResult);
  }
}
```



### 常用的事件类有

- GestureDetector
- TapGestureRecognizer
- LongPressGestureRecognizer
- DragGestureRecognizer
- PointerEvent





## 图片加载是如何实现的？有哪些常用的图片加载库？

图片加载是通过`Image`组件实现的，支持各自图片源，包括资源包、本地资源、网络和内存中的图片数据

- Image.asset
- Image.network
- Image.file
- Image.memory





## 文本处理是如何实现的？有哪些常用的文本类？

文本处理通过`Text`组件和其它文本类来实现的，并提供文本样式处理和布局属性



以下是常用文本类

- Text-文本
- RichText-富文本
- TextField-文本输入框
- TextFormField-表单文本输入框
- TextEditingController-文本控制器







## Flutter中的主题是如何实现的？有哪些常用的主题类？

Flutter中的主题是通过`Theme`组件和`ThemeData`类实现的，可以实现整个App风格的统一。设置`Theme`主题后，应用程序中的某些`Widget`就会直接使用主题的样式。`Theme`分为全局和局部主题，全局`Theme`定义在app的root处，而`MaterialApp`已经事先预设了一个全局的`Theme Widget`。



**使用主题样式**

一旦应用程序被`Theme`组件嵌套并设置了主题，那么就可以在组件下的任意位置使用主题的样式。例如`Theme.of(context)`来获取当前主题的样式

```dart
Text(
	'Hello,Theme!',
    style: Theme.of(context).textTheme.headline6,
)
```



通过使用主题，可以一次性定义应用程序的整体样式，然后在各个部分组件重复使用主题的样式。如果需要更改主题，只需要更新`ThemeData`对象，整个应用程序的样式将会自动更新



常用主题类

1. MaterialApp---Material应用程序主题
2. CupertinoApp---Cupertino应用程序主题
3. ThemeData---通用主题数据
4. CupertinoThemeData---Cupertino主题数据





## Flutter中的动态主题是如何实现的？

动态主题可以使用状态管理库(如 provider)来实现。

首先定义至少两个`ThemeData`对象，分别代表不同的主题

```dart
final ThemeData lightTheme = ThemeData(
  brightness: Brightness.light,
  primaryColor: Colors.blue,
  // 其他亮色主题样式和属性
);

final ThemeData darkTheme = ThemeData(
  brightness: Brightness.dark,
  primaryColor: Colors.deepPurple,
  // 其他暗色主题样式和属性
);
```

创建一个继承自`ChangeNotifier`的类，用于管理当前主题的状态

```dart
import 'package:flutter/foundation.dart';

class ThemeProvider extends ChangeNotifier {
  ThemeData _currentTheme = lightTheme;

  ThemeData get currentTheme => _currentTheme;

  void setTheme(ThemeData theme) {
    _currentTheme = theme;
    notifyListeners();
  }
}
```

**在`main.dart`中使用`ChangeNotifierProvider`**: 在应用程序的顶层，使用`ChangeNotifierProvider`包裹`MaterialApp`，以使`ThemeProvider`可用。

```dart
void main(){
    runApp(
    	ChangeNotifierProvider(
        	create: (context) => ThemeProvider(),
            child: MyApp(),
        ),
    );
}
```

使用`Consumer`组件获取`ThemeProvidr`并获取当前的主题

```dart
Consumer<ThemeProvider>(
  builder: (context, themeProvider, child) {
    return MaterialApp(
      theme: themeProvider.currentTheme,
      home: MyHomePage(),
    );
  },
)
```

**切换主题**

```dart
final themeProvider = Provider.of<ThemeProvider>(context, listen: false);
themeProvidr.setTheme(darkTheme);//切换为暗色主题
```



通过以上步骤，可以使用`Provider`实现动态主题功能。当切换主题时，`ThemeProvider`会通知依赖于它的`Consumer`重新构建，这就实现了动态主题





## Flutter中的手势识别是如何实现的？

Flutter中的手势有两个不同的层次；

1. 第一层是原始的指针指向事件，描述了屏幕上由触摸板、鼠标、指示笔等触发的指针的位置和移动
2. 第二层包含`gestures`，描述了由上述一个或多个指针移动组成的具有特殊语义的操作



### 手势竞技场

在屏幕的指定位置上，可能会有多个`GestureDetector`，所有的`GestureDetector`监听了指针输入流事件(PointerDownEvent)并判断出特点的手势(onTapDown)。如果`GestureDetector`组件的回调事件为空时则不去识别该手势



当屏幕上的指定指针有多个`GestureDetector`时，Flutter框架会通过给每个`GestureDetector`加入`手势竞技场`，会利用以下规则确定哪个`GestureDetector`在竞技中胜出

- 在任何时候，`GestureDetector`都可以宣告失败并离开竞技场。如果竞技场中只有一个识别器，那么这个识别器就是胜者
- 在任何时候，任何`GestureDetector`都可以宣告胜利，这将导致这个`GestureDetector`胜出，其它`GestureDetector`失败

比如，当横向与纵向拖动需要进行竞技时，当指针下落事件发生时，这两个识别器都会进入竞技场，观测指针移动事件。如果用户在横向上的移动超过了特定像素，横向识别器会宣告胜利，手势也会被当作横向拖动处理，反之亦然。

手势竞技场只有一个识别器时是非常高效的，因为不需要进行手势竞技







## Flutter中的状态管理是如何实现的？有哪些常用的状态管理库？

1. 使用基础的`setState`，

   Flutter提供了一个基本的状态管理方式，通过使用`setState`函数来更新小部件的状态。当调用`setState`时，Flutter会重新构建目标组件，并根据新的状态值更新UI

   ```dart
   setState((){
       //在这里面更新状态值
   })
   ```

2. Provider

   它使用`ChangeNotifier`和`Provider`来管理和共享状态。通过在组件树中使用`Provider`和`Consumer`小部件，可以轻松访问、更新和共享状态

   ```dart
   class Counter with ChangeNotifier {
       int _count = 0;
       int get count => _count;
       
       void increment(){
           _count++;
           notifyListeners();
       }
   }
   
   class MyWidget extends StatelessWidget {
     @override
     Widget build(BuildContext context) {
         final counter = Provider.of<Counter>(context,listen: false);
         
         return RaisedButton(
         	onPressed: (){
               counter.increment();
           },
           child: Consumer<Counter>(
           	builder:(context,counter,child){
                   return Text('${counter.count}');
           },
         ),
       );
     }
   }
   ```

3. Bloc

   Bloc使用`Stream`和`StreamController`来管理状态和事件，使得状态管理更加可预测和可扩展

   ```dart
   class CounterBloc{
       final _counterController = StreamController<int>();
       Stream<int> get counterStream => _counterController.stream;
       
       int _count = 0;
       
       void increment(){
           _count++;
           _counterController.sink.add(_count);
       }
       
       void dispose(){
           _counterController.close();
       }
   }
   
   class MyWidget extends StatelessWidget {
       final _counterBloc = CounterBloc();
       
       @override
     	Widget build(BuildContext context) {
         return StreamBuilder<int>(
         	  stream: _counterBloc.counterStream,
             initialData: 0,
             builder:(context, snapshot) {
                 return RaisedButton(
                 	onPressed: (){
                       _counterBloc.increment();
                   },
                   child: Text('${snapshot.data}'),
                 );
             },
         );
     }
       
       @override
       void dispose(){
           _counterBloc.dispose();
       	super.dispose();
       }
   }
   ```

   

常用的状态管理库有

1. Provider
2. Bloc
3. GetX
4. Redux
5. Riverpod





## Flutter中网络请求是如何实现的？

在Flutter中，可通过Dart自带的`HttpClient`或者第三方库来实现网络请求

- Dart自带的`HttpClient`

  ```dart
  import 'dart:io';
  
  void fetchData() async {
      var client = HttpClient();
      var url = Uri.parse('https://api.example.com/data');
      
      try{
          var request = await client.getUrl(url);
          var response = await request.close();
          
          if(response.statusCode == HttpStatus.ok) {
              var data = await response.transform(utf8.decoder).join();
              //处理响应数据
          } else {
              //处理错误情况
          }
      } catch (e) {
          //处理异常
      } finally {
          client.close();
      }
  }
  ```

- Dio

  Dio支持拦截器、全局配置、FormData、请求取消、文件上传下载、处理超时等功能

  首先导入Dio依赖

  ```yaml
  dependencies:
    dio: ^4.0.0
  ```

  ```dart
  import 'package:dio/dio.dart';
  
  final dio = Dio();
  
  try {
      final response = await dio.get('https://mock.presstime.cn/mock/63e33df047892c65279783be/example/test');
      print(response.data);
  } catch (e) {
      print(e);
  } finally {
      dio.cancle()
  }
  ```

- Http

  ```dart
  import 'package:http/http.dart' as http;
  
  void fetchData() async {
      var url = Uri.parse('https://api.example.com/data');
      
      var response = await http.get(url);
      
      if (response.statusCode == 200) {
          var data = response.body;
          //处理响应数据
      } else {
          //处理错误情况
      }
  }
  ```

  在上述示例中，导入`http`库后，并将其命名为`http`以便使用。

  然后我们使用`Uri.parse()`方法将URL字符串解析为`Uri`对象。

  接下来使用`http.get()`方法发送 `HTTP GET`请求，并通过`await`关键字等待响应。

  再通过响应的状态码，我们可以判断请求是否成功





## Dio详解

### Dio介绍

#### Dio接收

dio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时处理、自定义适配器等

#### 关键词解释

1. API

   API(Application Programming Interface，应用程序接口)是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而有无需访问源码，或理解内部工作机制的细节

2. REST

   REST即表述性状态传递(Representational State Transfer)。简单来说，就是用`Uri`表示资源，用HTTP方法(GET,POST,PUT,DELETE)表征对这些资源的操作

3. FromData

   `Dio`支持发送`FormData`，请求数据将会以`multipart/form-data`方式编码，`FormData中`可以一个或者多个包含文件。主要目的用于文件上传操作

   ```xml
   只有post方法支持发送FormData
   ```

4. 拦截器

   每个Dio实例都可以添加任意多个拦截器，他们组成一个队列，拦截器队列的执行顺序是`FIFO`先进先出（First in First out）原则。通过拦截器你可以在请求前、响应后和发生异常时（但还没有被then或catchError）做一些统一的预处理操作

5. 请求取消

   可以通过`cancel token`来取消发起的请求

6. Cookie管理

   `CookieManager`拦截器可以帮助我们自动管理请求、响应cookie

7. 文件上传/下载

   Dio支持单文件和多文件的上传及下载

8. 超时

   Dio可设定超时时间，当在设定时间内未响应，将报错

9. 自定义适配器

   内置的适配器可无缝切换到别的请求库而不用改之前的代码

#### 简单示例

```dart
void _fetchData() async {
    try {
        var response = await Dio().get('www.xxx.com');
    } catch (e) {
        //处理异常
    }
}
```





### 与其它网络请求方式对比

#### 系统自带网络请求HttpClient

1. 创建一个HttpClient

   ```dart
   HttpClient httpClient = HttpClient();
   ```

2. 打开http连接，设置请求头

   ```dart
   HttpClientRequest request = await httpClient.getUrl(Url.parse('www.xxx.com'));
   ```

3. 通过HttpClientRequest可以设置请求header

   ```dart
   request.headers.add('token','token');
   ```

4. 等待连接服务器

   ```dart
   HttpClientResponse response = await request.close();
   ```

5. 读取响应内容

   ```dart
   // 响应流数据以utf8编码格式返回
   String responseBody = await response.transform(utf8.decoder).join();
   ```

6. 请求结束，关闭httpClient

   ```dart
   httpClient.close();
   ```

#### 第三方网络请求库Http

1. 导入库

   ```dart
   import 'package:http/http.dart' as http;
   ```

2. 发起请求

   ```dart
   final url = Uri.parse('www.xxx.com');
   final response = await http.get(url);
   ```

3. 处理响应

   ```dart
   if (response.statusCode == 200) {
       return Post.fromJson(jsonDecode(response.body));
   } else {
       throw Exception('Failed to load post: $postId');
   }
   ```



### 深度剖析

#### 从post请求来进行分析

```dart
var response = await Dio().post('http://xxx.com', queryParameters: {
    'username': '123456',
    'password': '123456'
});
```

#### post方法

`post`方法有七个参数，在该方法中调用了`request`方法，并没有做任何处理，接下来分析`request`方法

1. path：请求的url链接
2. data：请求数据，例如上传用到的FormData
3. queryParameters：查询参数
4. options：请求选项
5. cancelToken：用来取消发送请求的token
6. onSendProgress：网络请求发送的进度
7. onReceiveProgress：网络请求接收的进度

```dart
@override
Future<Response<T>> post<T>(
	String path, {
    data,
    Map<String, dynamic>? queryParameters,
    Options? options,
    CancelToken? cancelToken,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
}) {
    return request<T> (
    	path,
        data: data,
        options: checkOptions('POST', options),
        queryParameters: queryParameters,
        cancelToken: cancelToken,
        onSendProgress: onSendProgress,
        onReceiveProgress: onReceiveProgress,
    );
}
```



#### request方法

`request`方法接收了`post`方法中传进来的参数



##### 第一步：合并选项

通过调用`compose`方法来进行选项合并。



###### compose方法执行流程

1. 首先判断`queryParameters`是否为空，不为空则添加到一个`query`临时变量中
2. 把`options`中的`headers`全部拿出来存到临时变量`_headers`中进行不区分大小写的映射，并删除`headers`中的`contentTypeHeader` 
3. 如果`headers`不为空，则把`headers`中的全部属性添加到临时变量`_headers`中并把`contentTypeHeaders`赋值到一个临时变量`_contentType`中
4. 把`options`中的自定义字段`extra`赋值给一个临时变量
5. 把`method`统一转换成大写字母
6. 创建一个`RequestOptions`并传入上面处理过的参数并返回

###### compose源码

```dart
RequestOptions compose(
  BaseOptions baseOpt,
  String path, {
    data,
    Map<String, dynamic>? queryParameters,
    CancelToken? cancelToken,
    Options? options,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) {
  var query = <String, dynamic>{};
  if (queryParameters != null) query.addAll(queryParameters);
  query.addAll(baseOpt.queryParameters);

  var _headers = caseInsensitiveKeyMap(baseOpt.headers);
  _headers.remove(Headers.contentTypeHeader);

  var _contentType;

  if (headers != null) {
    _headers.addAll(headers!);
    _contentType = _headers[Headers.contentTypeHeader];
  }

  var _extra = Map<String, dynamic>.from(baseOpt.extra);
  if (extra != null) {
    _extra.addAll(extra!);
  }
  var _method = (method ?? baseOpt.method).toUpperCase();
  var requestOptions = RequestOptions(
    method: _method,
    headers: _headers,
    extra: _extra,
    baseUrl: baseOpt.baseUrl,
    path: path,
    data: data,
    connectTimeout: baseOpt.connectTimeout,
    sendTimeout: sendTimeout ?? baseOpt.sendTimeout,
    receiveTimeout: receiveTimeout ?? baseOpt.receiveTimeout,
    responseType: responseType ?? baseOpt.responseType,
    validateStatus: validateStatus ?? baseOpt.validateStatus,
    receiveDataWhenStatusError:
    receiveDataWhenStatusError ?? baseOpt.receiveDataWhenStatusError,
    followRedirects: followRedirects ?? baseOpt.followRedirects,
    maxRedirects: maxRedirects ?? baseOpt.maxRedirects,
    queryParameters: query,
    requestEncoder: requestEncoder ?? baseOpt.requestEncoder,
    responseDecoder: responseDecoder ?? baseOpt.responseDecoder,
    listFormat: listFormat ?? baseOpt.listFormat,
  );

  requestOptions.onReceiveProgress = onReceiveProgress;
  requestOptions.onSendProgress = onSendProgress;
  requestOptions.cancelToken = cancelToken;

  requestOptions.contentType = _contentType ??
    contentType ??
    baseOpt.contentTypeWithRequestBody(_method);
  return requestOptions;
}
```



##### 第二步：调用fetch

判断用户是否关闭请求，关闭则退出，未关闭则调用fetch方法

###### request源码

```dart
 @override
  Future<Response<T>> request<T>(
    String path, {
    data,
    Map<String, dynamic>? queryParameters,
    CancelToken? cancelToken,
    Options? options,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    options ??= Options();
    var requestOptions = options.compose(
      this.options,
      path,
      data: data,
      queryParameters: queryParameters,
      onReceiveProgress: onReceiveProgress,
      onSendProgress: onSendProgress,
      cancelToken: cancelToken,
    );
    requestOptions.onReceiveProgress = onReceiveProgress;
    requestOptions.onSendProgress = onSendProgress;
    requestOptions.cancelToken = cancelToken;

    if (_closed) {
      throw DioError(
        requestOptions: requestOptions,
        error: "Dio can't establish new connection after closed.",
      );
    }

    return fetch<T>(requestOptions);
  }
```



#### fetch方法

###### 第一步：请求参数赋值

判断如果传递进来的`requestOptions.cancelToken`不为空的情况下，则把传递进来的`requestOptions`进行赋值

```dart
if(requestOptions.cancelToken != null) {
    requestOptions.cancelToken!.requestOptions = requestOptions;
}
```

###### 第二步：响应数据设定

如果请求回来的参数不是动态类型并且不是`bytes`和`stream`的方式，则进行判断该返回值类型是否是字符串，为真则返回UTF-8的编码类型，否则返回字符串类型

```dart
if (T != dynamic && 
   	!(requestOptions.responseType == ResponseType.bytes ||
      requestOptions.responseType == ResponseType.stream)) {
    if (T == String) {
        requestOptions.responseType = ResponseType.plain;
    } else {
        requestOptions.responseType = ResponseType.json;
    }
}
```

###### 第三步：构建请求流并添加拦截器

1. 构建一个请求流，`InterceptorState`是一个内部类，里面总共有两个属性`T data`以及`InterceptorResultType type`，用于当前拦截器和下一个拦截器之间传递状态所定义
2. 按FIFO顺序执行，循环遍历向请求流中添加请求拦截器，拦截器中最主要有`RequestInterceptor`请求前拦截和`ResponseInterceptor`请求后拦截的两个实例

```dart
var future = Future<dynamic>(() => InterceptorState(requsetOptions));

interceptors.forEach((Interceptor interceptor) {
    future = future.then(_requestInterceptorWrapper(interceptor.onRequest));
})
```



###### 第四步：拦截器转换为函数回调

这里主要做的一步操作就是把函数的回调作为方法的参数，这样就实现了把拦截器转换为函数回调，这里做了一层判断，如果`state.type`等于`next`的话，那么会增加一个监听取消的异步任务，并把`cancelToken`传递给了这个任务，接下来它会检查当前这个拦截器的请求是否入队，最后定义了一个i请求拦截器的变量，该拦截器里面有桑主要的方法分别是`next()`,`resole()`,`reject()`，最后把这个拦截器返回出去

```dart
FutureOr Function(dynamic) _requestInterceptorWrapper(
  void Function(
    RequestOptions options,
    RequestInterceptorHandler handler,
  )
  interceptor,
) {
  return (dynamic _state) async {
    var state = _state as InterceptorState;
    if (state.type == InterceptorResultType.next) {
      return listenCancelForAsyncTask(
        requestOptions.cancelToken,
        Future(() {
          return checkIfNeedEnqueue(interceptors.requestLock, () {
            var requestHandler = RequestInterceptorHandler();
            interceptor(state.data, requestHandler);
            return requestHandler.future;
          });
        }),
      );
    } else {
      return state;
    }
  };
}
```



###### 第五步：构建请求流调度回调

调度回调和添加拦截器转换为函数回调，不同的是调度回调里面进行了请求分发

```dart
future = future.then(_requestInterceptorWrapper((
  RequestOptions reqOpt,
  RequestInterceptorHandler handler,
) {
  requestOptions = reqOpt;
  _dispatchRequest(reqOpt).then(
    (value) => handler.resolve(value, true),
    onError: (e) {
      handler.reject(e, true);
    },
  );
}));
```

###### 第六步：请求分发

1. 请求分发函数里面会调用`_transformData`进行数据转换，最终转换出来的数据是一个`Stream`流
2. 调用网络请求适配器进行网络请求`fetch`方法，这里说明下该适配器定义有两个，
   1. `BrowserHttpClientAdapter`是调用了`html_dart2js`的库进行了网络请求，该库是将`dart`代码编译成可部署的JavaScript
   2. `DefaultHttpClientAdapter`是采用系统请求库`HttpClient`进行网络请求
3. 把响应头赋值给临时变量`responseBody`并通过`fromMap`转换成`Map<String, List<String>>`类型
4. 初始化响应类，并对返回的数据进行赋值处理
5. 判断如果是正常返回的话就对`ret.data`变量进行数据格式转换，失败则取消监听响应流
6. 根据变量`cancelToken`判断是否取消请求了，如果取消了则直接抛出异常
7. 最后再判断请求是否正常，如果正常则检查是否入队并返回，否则直接抛出请求异常`DioError`

```dart
Future<Response<T>> _dispatchRequest<T>(RequestOptions reqOpt) async {
  var cancelToken = reqOpt.cancelToken;
  ResponseBody responseBody;
  try {
    var stream = await _transformData(reqOpt);
    responseBody = await httpClientAdapter.fetch(
      reqOpt,
      stream,
      cancelToken?.whenCancel,
    );
    responseBody.headers = responseBody.headers;
    var headers = Headers.fromMap(responseBody.headers);
    var ret = Response(
      headers: headers,
      requestOptions: reqOpt,
      redirects: responseBody.redirects ?? [],
      isRedirect: responseBody.isRedirect,
      statusCode: responseBody.statusCode,
      statusMessage: responseBody.statusMessage,
      extra: responseBody.extra,
    );
    var statusOk = reqOpt.validateStatus(responseBody.statusCode);
    if (statusOk || reqOpt.receiveDataWhenStatusError == true) {
      var forceConvert = !(T == dynamic || T == String) &&
        !(reqOpt.responseType == ResponseType.bytes ||
          reqOpt.responseType == ResponseType.stream);
      String? contentType;
      if (forceConvert) {
        contentType = headers.value(Headers.contentTypeHeader);
        headers.set(Headers.contentTypeHeader, Headers.jsonContentType);
      }
      ret.data = await transformer.transformResponse(reqOpt, responseBody);
      if (forceConvert) {
        headers.set(Headers.contentTypeHeader, contentType);
      }
    } else {
      await responseBody.stream.listen(null).cancel();
    }
    checkCancelled(cancelToken);
    if (statusOk) {
      return checkIfNeedEnqueue(interceptors.responseLock, () => ret)
        as Response<T>;
    } else {
      throw DioError(
        requestOptions: reqOpt,
        response: ret,
        error: 'Http status error [${responseBody.statusCode}]',
        type: DioErrorType.response,
      );
    }
  } catch (e) {
    throw assureDioError(e, reqOpt);
  }
}
```



#### download方法

`download`方法的执行流程和`post`一样，只是接收的数据类型以及逻辑处理不一样，会把下载的文件存到本地



#### 总结

在我们进行`get()`,`post()`等调用网络请求时，都会进入到`request`方法，`request`方法主要负责对请求参数以及自定义请求头的统一处理，并调用了`fetch`方法，而`fetch`方法中是对响应数据设定、构建请求流、添加拦截器、请求分发的操作







### Dio封装

#### 使用单例模式进行Dio封装



##### 为什么使用单例模式

因为我们的应用程序在每个页面中都会用到网络请求，那么如果我们每次请求的时候都去实例化一个`Dio`无非是增加了系统不必要的开销，而使用单例模式对象一旦创建那么每次访问的都是同一个对象，不需要再次实例化该类的对象



##### 创建单例类

通过静态变量的私有构造器来创建的单例模式

```dart
class DioUtill {
    factory DioUtil() => _getInstance();
    static DioUtil get instance => _getInstance();
    static DioUtil _instance;
    
    DioUtil._init() {
        // 初始化
    }
    
    static DioUtil _getInstance() {
        if (_instance == null) {
            _instance = DioUtil._init();
        }
        return _instance;
    }
}
```



#### 对Dio请求进行初始化

我们对 **超时时间**、**响应时间**、**BaseUrl**进行统一设置

```dart
/// 连接超时时间
static const int CONNECT_TIMEOUT = 1000 * 30;
/// 响应超时时间
static const int RECEIVE_TIMEOUT = 1000 * 30;

/// 声明Dio变量
Dio _dio;

DioUtil._init() {
    if (_dio == null) {
        /// 初始化基本选项
        BaseOptions options = BaseOptions(
        	baseUrl: 'http://123123',
            connectTimeout: CONNECT_TIMEOUT,
            receiveTimeout: RECEIVE_TIMEOUT
        );
        
        /// 初始化Dio
        _dio = Dio(options);
    }
}
```



##### 对Restful API风格进行统一封装

因为不管是`get`还是`post`请求，`Dio`内部最终都会调用`request`方法，只是传入的`method`不一样，所以我们这里定义一个枚举类型在一个方法中进行处理

```dart
/// 枚举类
enum DioMethod {
    get,
    post,
    put,
    delete,
    patch,
    head,
}

/// 请求类
Future<T> request<T>(String path, {
    DioMethod method = DioMethod.get,
    Map<String, dynamic> params,
    data,
    CancelToken cancelToken,
    Options options,
    ProgressCallback onSendProgress,
    ProgressCallback onReceiveProgress,
}) async {
    const _methodValues = {
        DioMethod.get: 'get',
        DioMethod.post: 'post',
    	DioMethod.put: 'put',
    	DioMethod.delete: 'delete',
    	DioMethod.patch: 'patch',
    	DioMethod.head: 'head'
    };
    
    options ??= Options(method: methodValues[method]);
    try {
        Response response;
        response = await _dio.request(
        	path,
            data: data,
            queryParameters: params,
            cancelToken: cancelToken,
            options: options,
            onSendProgress: onSendProgress,
            onReceiveProgress: onReceiveProgress
        );
        return response.data;
    } on DioError catch (e) {
        throw e;
    }
}
```



#### 拦截器

##### 介绍

我们已经把`Restful API`风格简化成了一个方法，通过`DioMethod`来标明不同的请求方式。在我们平时开发过程中，需要在请求前、响应前、错误时对某一些接口做特殊的处理，那我们就需要用到拦截器。`Dio`为我们提供了自定义拦截器功能，很容易轻松的实现对请求前、响应前、错误时进行拦截



##### 错误统一处理

我们发现虽然`Dio`框架已经封装了`DioError`类，但如果需要对返回的错误进行统一弹窗处理或者路由跳转等需求就只能自定义了



##### 请求前统一处理

在我们发送请求的时候会碰到几种情况，比如需要对`非open`开头的接口加上一些特定的参数，获取接口参数需要在请求头增加统一的`token`



##### 响应前统一处理

在我们请求接口前可以对响应数据进行一些基础的处理，比如对响应的结果进行自定义封装，还可以针对单独的`url`做特殊的处理等



##### 自定义拦截器代码实现

###### 拦截器部分

```dart
class DioInterceptors extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    super.onRequest(options, handler);
    //  对非open的接口的请求参数全部增加userId
    if (!options.path.contains("open")) {
      options.queryParameters['userId'] = 'xxx';
    }

    // 头部添加token
    options.headers['token'] = 'xxx';

    // 更多业务需求
    handler.next(options);
  }

  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    super.onResponse(response, handler);

    // 请求成功时对数据做基本处理
    if (response.statusCode == 200) {
      response.data = DioResponse(code: DioResponseCode.SUCCESS, message: '请求成功', data: response);
    } else {
      response.data = DioResponse(code: DioResponseCode.ERROR, message: '请求失败', data: response);
    }

    // 对某些单独的url返回数据进行特殊处理
    if (response.requestOptions.baseUrl.contains('xxxxxx')) {
      //......
    }

    // 根据夜晚需求进行定制化处理

    // 重点
    handler.next(response);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    super.onError(err, handler);

    switch (err.type) {
      // 连接服务器超时
      case DioExceptionType.connectionTimeout:
        {
          // 根据自己的业务需求来制定如何操作，可以是弹出提示框/或者做一些路由跳转处理
        }
        break;
      //响应超时
      case DioExceptionType.receiveTimeout:
        {
          // 根据自己的业务需求来制定如何操作，可以是弹出提示框/或者做一些路由跳转处理
        }
        break;
      // 发送超时
      case DioExceptionType.sendTimeout:
        {
          // 根据自己的业务需求来制定如何操作，可以是弹出提示框/或者做一些路由跳转处理
        }
        break;
      // 请求取消
      case DioExceptionType.cancel:
        {
          // 根据自己的业务需求来制定如何操作，可以是弹出提示框/或者做一些路由跳转处理
        }
        break;
      // ValidateStatus配置的不正确的状态码
      case DioExceptionType.badResponse:
        {
          // 根据自己的业务需求来制定如何操作，可以是弹出提示框/或者做一些路由跳转处理
        }
        break;
      // 未知或其它错误
      case DioExceptionType.unknown:
        {
          // 根据自己的业务需求来制定如何操作，可以是弹出提示框/或者做一些路由跳转处理
        }
        break;
      case DioExceptionType.badCertificate:
        {
          // 根据自己的业务需求来制定如何操作，可以是弹出提示框/或者做一些路由跳转处理
        }
        break;
      case DioExceptionType.connectionError:
        {
          // 根据自己的业务需求来制定如何操作，可以是弹出提示框/或者做一些路由跳转处理
        }
        break;
    }
  }
}
```

###### 响应数据封装

```dart
class DioResponse<T> {
  ///消息(例如成功消息文字/错误消息文字)
  final String message;

  ///自定义code（可根据内部定义方式）
  final int code;

  ///接口返回的数据
  final T data;

  ///更多自定义响应数据
  ///......

  DioResponse({
    required this.code,
    required this.message,
    required this.data,
  });

  @override
  String toString() {
    StringBuffer stringBuffer = StringBuffer('{');
    stringBuffer.write("\"message\":\"$message\"");
    stringBuffer.write("\"errorMsg\":\"$code\"");
    stringBuffer.write("\"data\":\"$data\"");
    stringBuffer.write('}');
    return stringBuffer.toString();
  }
}
```

###### 响应状态码封装

```dart
class DioResponseCode {
  /// 成功
  static const int SUCCESS = 0;

  /// 错误
  static const int ERROR = 1;

  /// 更多
}
```



#### 转换器

##### 介绍

转换器`Transformer`用于对请求数据和响应数据进行编码解码处理。Dio实现了一个默认转换器`DefaultTransformer`作为默认的`Transformer`，如果想对请求/响应数据进行自定义编码解码处理，可以使用自定义转换器



##### 为什么需要转换器

我们看了转换器的介绍，发现和拦截器的功能差不多，那为什么还需要转换器呢，有以下两点

1. 和拦截器解耦
2. 不修改原始请求数据

**执行流程：请求拦截器>>请求转换器>>发起请求>>响应转换器>>响应拦截器>>最终结果**



##### 请求转换器

只会被用于`PUT`,`POST`,`PATCH`方法，因为只有这些方法才可以携带请求体(request body)



##### 响应转换器

会被用于所有请求方法的返回数据



##### 自定义转换器实现

```dart
class DioTransformer extends BackgroundTransformer {
  @override
  Future<String> transformRequest(RequestOptions options) {
    // 如果请求的数据接口是List<String>那我们直接抛出异常
    if (options.data is List<String>) {
      throw DioException(
        error: '你不能直接发送List数据到服务器',
        requestOptions: options,
      );
    } else {
      return super.transformRequest(options);
    }
  }

  @override
  Future transformResponse(RequestOptions options, ResponseBody response) {
    // 例如我们响应选项里面没有自定义某些头部数据，那我们就可以自行添加
    options.extra['myHeader'] = '自定义的头部数据';
    return super.transformResponse(options, response);
  }
}
```



#### 刷新Token

在开发过程中，客户端和服务器打交道的时候，往往会用到一个`token`来做校验，因为每个业务需求处理刷新token的逻辑都不一样，这里简单的举一个例子

> 我们需要给所有的请求头中添加一个 `refreshToken`，如果 `refreshToken`不存在，我们先去请求 `refreshToken`，获取到 refreshToken后，再发起后续请求。由于请求refreshToken的过程是异步的，我们需要在请求过程锁定后续请求（因为它们需要refreshToken），直到refreshToken请求成功后，再解锁

```dart
import 'package:dio/dio.dart';
import 'package:flutter_dio/dio_util/dio_util.dart';

class DioTokenInterceptors extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    if (options.headers['refreshToken'] == null) {
      DioUtil.instance.dio.lock();
      Dio _tokenDio = Dio();
      _tokenDio..get("http://localhost:8080/getRefreshToken").then((d) {
        options.headers['refreshToken'] = d.data['data']['token'];
        handler.next(options);
      }).catchError((error, stackTrace) {
        handler.reject(error, true);
      }) .whenComplete(() {
        DioUtil.instance.dio.unlock();
      }); // unlock the dio
    } else {
      options.headers['refreshToken'] = options.headers['refreshToken'];
      handler.next(options);
    }
  }

  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) async {

    // 响应前需要做刷新token的操作

    super.onResponse(response, handler);
  }

  @override
  void onError(DioError err, ErrorInterceptorHandler handler) {
    super.onError(err, handler);
  }
}
```





#### 网络接口缓存

##### 为什么使用缓存

因为在我们平时的开发过程中，会碰到一种情况，在进行网络请求时，我们希望能正常访问到上次的数据，对于用户的体验比较好，而不是展示一个空白的页面。

##### 使用shared_preferences持久化

我们在程序退出后内存缓存将会消失，所以我们用 `shared_preferences`进行磁盘缓存数据



## Flutter中常用的设计模式



